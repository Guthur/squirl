(defpackage #:squirl-demo-2
  (:use :cl :squirl))
(in-package :squirl-demo-2)

(defparameter *physics-timestep* 1/100)
(defparameter *accumulator* 0)

(defparameter *world-x-offset* 0)
(defparameter *world-y-offset* 0)
(defparameter *body-radius* 1) ;;for visualisation

(defun world-box (a1 b1 a2 b2 a3 b3 a4 b4 world)
  (let ((body (make-body :position (vec 0 0)))
	(shape (make-segment a1 b1 :restitution 1 :friction 1)))
    (attach-shape shape body)
    (setf shape (make-segment a2 b2 :restitution 1 :friction 1))
    (attach-shape shape body)
    (setf shape ( make-segment a3 b3 :restitution 1 :friction 1))
    (attach-shape shape body)
    (setf shape (make-segment a4 b4 :restitution 1 :friction 1))
    (attach-shape shape body)
    (world-add-body world body)))

(defun init-world ()
  (reset-shape-id-counter)
  (let* ((world (make-world :gravity (vec 0 50))))
    (world-box (vec -320 -240) (vec -320 240) (vec 320 -240) (vec 320 240)
	       (vec -320 -240) (vec 320 -240)
	       (vec -320 240) (vec 320 240)
	       world)
    (return-from init-world world)))

(defun update (ticks world)
  (incf *accumulator* (min ticks 0.5))
  (loop while (>= *accumulator* *physics-timestep*)
     do (world-step world *physics-timestep*)
        (decf *accumulator* *physics-timestep*)))

(defun add-circle (world)
  (let* ((size 10.0)
	 (mass 1.0)
	 (radius (vec-length (vec size size))))
    (let ((body (make-body :mass (moment-for-circle mass 1.0 size) :position (vec 0 0)))
	  (shape (make-circle radius :restitution 1 :friction 1)))
      (setf (body-position body) (vec (- (random-percent-of 640) 320) (- (random-percent-of 480) 240)))
      (setf (body-velocity body) (vec (- (random-percent-of 50) 25) (- (random-percent-of 50) 25)))
      (attach-shape shape body)
      (world-add-body world body))))

(defun random-percent-of (num)
  (* num (/ (1+ (random 99d0)) 100)))

(defun add-box (world)
  (let* ((size 10.0)
	 (mass 1.0)
	 (verts (list (vec (- size) (- size)) (vec (- size) size) (vec size size) (vec size (- size))))
	 (body (make-body :mass (moment-for-poly mass verts)))
	 (shape (make-poly verts :restitution 1 :friction 1)))
    (setf (body-position body) (vec (- (random-percent-of 640) 320) (- (random-percent-of 480) 240)))
    (setf (body-velocity body) (vec (- (random-percent-of 50) 25) (- (random-percent-of 50) 25)))
    (attach-shape shape body)
    (world-add-body world body)))

(defgeneric draw-shape (shape color))

(defun body-with-color (color)
  (lambda (element)
    (draw-body element color)))

(defun draw-body (body color)
  (let ((x (round (vec-x (body-position body))))
	(y (round (vec-y (body-position body)))))
    (sdl:draw-filled-circle-* (+ x *world-x-offset*) (+ y *world-y-offset*) *body-radius* :color color)))

(defun shape-with-color (color)
  (lambda (element)
    (draw-shape element color)))

(defmethod draw-shape ((shape circle) color)
  (let ((x (round (vec-x (circle-transformed-center shape))))
	(y (round (vec-y (circle-transformed-center shape)))))
    (sdl:draw-circle-* (+ x *world-x-offset*) (+ y *world-y-offset*) (round (circle-radius shape)) :color color)))

(defmethod draw-shape ((shape poly) color)
  (let ((1st-vert-x (round (vec-x (elt (poly-transformed-vertices shape) 0))))
	(1st-vert-y (round (vec-y (elt (poly-transformed-vertices shape) 0)))))
    (do ((vert1-x 0) (vert1-y 0) (vert2-x 0) (vert2-y 0)
	 (index 1 (1+ index)))
	((= index (length (poly-transformed-vertices shape)))
	   (sdl:draw-line-* (+ vert2-x *world-x-offset*) (+ vert2-y *world-y-offset*) (+ 1st-vert-x *world-x-offset*) (+ 1st-vert-y *world-y-offset*) :color color))
      (setf vert1-x (round (vec-x (elt (poly-transformed-vertices shape) (1- index)))))
      (setf vert1-y (round (vec-y (elt (poly-transformed-vertices shape) (1- index)))))
      (setf vert2-x (round (vec-x (elt (poly-transformed-vertices shape) index))))
      (setf vert2-y (round (vec-y (elt (poly-transformed-vertices shape) index))))
      (sdl:draw-line-*  (+ vert1-x *world-x-offset*) (+ vert1-y *world-y-offset*)
			(+ vert2-x *world-x-offset*) (+ vert2-y *world-y-offset*)
			:color color))))

(defmethod draw-shape ((seg segment) color)
  (let ((x1 (round (vec-x (segment-trans-a seg))))
	(y1 (round (vec-y (segment-trans-a seg))))
	(x2 (round (vec-x (segment-trans-b seg))))
	(y2 (round (vec-y (segment-trans-b seg)))))
  (sdl:draw-line-* (+ x1 *world-x-offset*)  (+ y1 *world-y-offset*) (+ x2 *world-x-offset*) (+ y2 *world-y-offset*) :color color)))

(defun render (world)
  (sdl:clear-display sdl:*black*)
  (map-world-hash (shape-with-color sdl:*green*) (world-active-shapes world))
  (map-world-hash (shape-with-color sdl:*red*) (world-static-shapes world))
  (map 'vector (body-with-color sdl:*blue*) (world-bodies world))
  (sdl:update-display))

(defun now ()
  (/ (sdl:sdl-get-ticks) 1000))

(defun quick-and-dirty (&aux (world (init-world)))
  (sdl:with-init ()
    (sdl:window 800 600 :title-caption "SqirL SDL Demo" :icon-caption "SquirL")
    (setf *world-x-offset* (/ 800 2))
    (setf *world-y-offset* (/ 600 2))
    (let ((previous-tick (now)))
      (add-box world)
      (sdl:with-events ()
	(:idle ()
          (let ((now (now)))
            (update (- now previous-tick) world)
            (setf previous-tick now))
          (render world))
	(:quit-event () t)
	(:video-expose-event ()
          (sdl:update-display))
	(:key-down-event ()
          (when (sdl:key-down-p :sdl-key-escape)
            (sdl:push-quit-event))
          (when (sdl:key-down-p :sdl-key-b)
            (add-box world))
          (when (sdl:key-down-p :sdl-key-c)
            (add-circle world)))))))
